name: CI/CD Pipeline

on:
  push:
    branches: [main, develop, fix-sc2012-and-test-suite]
  pull_request:
    branches: [main]
  schedule:
    # Run weekly security scans
    - cron: "0 2 * * 1"

env:
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

jobs:
  lint-and-validate:
    name: Lint and Validate
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"

      - name: Cache npm dependencies
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('nodes/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install dependencies
        run: |
          echo "Current directory: $(pwd)"
          echo "Checking for package-lock.json in nodes directory:"
          ls -la nodes/package-lock.json
          cd nodes
          echo "Changed to directory: $(pwd)"
          npm ci

      - name: Lint shell scripts
        run: |
          sudo apt-get update
          sudo apt-get install -y shellcheck
          echo "Running enhanced shellcheck validation with source path following..."

          # Set up source paths for shellcheck to follow includes
          export SHELLCHECK_OPTS="--source-path=tests/helpers:tests:scripts --external-sources"

          # Run shellcheck with enhanced options on project scripts only
          # -x: Follow source/include statements
          # --source-path: Specify directories to search for sourced files
          # --format: Use clear error format for CI
          # --severity: Include all severity levels for comprehensive checking
          find . -name "*.sh" -type f \
            -not -path "*/node_modules/*" \
            -not -path "*/nodes/node_modules/*" \
            -not -path "*/data/*" \
            -not -path "*/.git/*" \
            -not -path "*/logs/*" | \
            xargs shellcheck -x --source-path=tests/helpers:tests:scripts --format=gcc --severity=style

          if [ $? -eq 0 ]; then
            echo "‚úÖ All shell scripts passed shellcheck validation"
          else
            echo "‚ùå Shellcheck validation failed - see errors above"
            echo "Please fix the shellcheck issues before merging"
            exit 1
          fi

      - name: Validate Docker Compose files
        run: |
          # Set up environment for validation
          cp .env.example .env
          sed -i 's/changeme123!/test_password_123!/g' .env
          sed -i 's/change-this-secure-password/test_secure_password!/g' .env
          sed -i 's/generate-32-character-key-here/test-encryption-key-32-characters/g' .env
          sed -i 's/generate-jwt-secret-here/test-jwt-secret-key/g' .env
          sed -i 's/N8N_HOST=localhost/N8N_HOST=n8n.localhost/g' .env
          sed -i 's/TRAEFIK_DASHBOARD_HOST=traefik.localhost/TRAEFIK_DASHBOARD_HOST=traefik-dashboard.localhost/g' .env
          sed -i 's|WEBHOOK_URL=http://localhost:5678/|WEBHOOK_URL=http://n8n.localhost/|g' .env

          echo "" >> .env
          echo "# CI Validation Overrides" >> .env
          echo "POSTGRES_DB=n8n_test" >> .env
          echo "POSTGRES_USER=n8n_test" >> .env
          echo "REDIS_DB=0" >> .env
          echo "N8N_LOG_LEVEL=info" >> .env

          # Validate all Docker Compose configurations
          echo "Validating basic configuration..."
          docker compose -f docker-compose.yml config --quiet

          echo "Validating Nginx configuration..."
          docker compose -f docker-compose.yml -f docker-compose.nginx.yml config --quiet

          echo "Validating Traefik configuration..."
          docker compose -f docker-compose.yml -f docker-compose.traefik.yml config --quiet

          echo "Validating monitoring configuration..."
          docker compose -f docker-compose.monitoring.yml config --quiet

          echo "‚úÖ All Docker Compose files validated successfully"

      - name: Lint JavaScript/TypeScript
        run: |
          cd nodes
          npm run lint || echo "Linting completed with warnings/errors"

      - name: Check formatting
        run: |
          cd nodes
          npm run format:check || echo "Formatting check completed"

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    permissions:
      security-events: write
      actions: read
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@0.28.0
        with:
          scan-type: "fs"
          scan-ref: "."
          format: "sarif"
          output: "trivy-ci-results.sarif"
          severity: "CRITICAL,HIGH"
          exit-code: "0" # Don't fail the build on vulnerabilities
          vuln-type: "os,library"
          scanners: "vuln"

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-ci-results.sarif"

      - name: Scan Docker images for vulnerabilities
        run: |
          # Pull and scan main images (using versions from docker-compose.yml)
          docker pull n8nio/n8n:1.111.1
          docker pull postgres:16-alpine
          docker pull redis:7.4.1-alpine3.20
          docker pull nginx:1.27.2-alpine3.20
          docker pull traefik:v3.1.6

          # Scan with Trivy (continue on error to not fail the build)
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy:latest image --severity HIGH,CRITICAL n8nio/n8n:1.111.1 || echo "N8N scan completed with issues"
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy:latest image --severity HIGH,CRITICAL postgres:16-alpine || echo "Postgres scan completed with issues"

      - name: Check for secrets
        if: github.event.before != github.sha
        uses: trufflesecurity/trufflehog@main
        continue-on-error: true
        with:
          path: ./
          extra_args: --only-verified --no-update

      - name: Skip TruffleHog if no new commits
        if: github.event.before == github.sha
        run: echo "Skipping TruffleHog scan - base and head commits are identical."

  test-deployment:
    name: Test Deployment
    runs-on: ubuntu-latest
    needs: [lint-and-validate]
    strategy:
      matrix:
        deployment: [basic, nginx, traefik, monitoring]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up environment
        run: |
          cp .env.example .env
          # Set test credentials and required variables
          sed -i 's/changeme123!/test_password_123!/g' .env
          sed -i 's/change-this-secure-password/test_secure_password!/g' .env
          sed -i 's/generate-32-character-key-here/test-encryption-key-32-characters/g' .env
          sed -i 's/generate-jwt-secret-here/test-jwt-secret-key/g' .env

          # Set host configuration for Traefik routing
          sed -i 's/N8N_HOST=localhost/N8N_HOST=n8n.localhost/g' .env
          sed -i 's/TRAEFIK_DASHBOARD_HOST=traefik.localhost/TRAEFIK_DASHBOARD_HOST=traefik-dashboard.localhost/g' .env
          sed -i 's|WEBHOOK_URL=http://localhost:5678/|WEBHOOK_URL=http://n8n.localhost/|g' .env

          # Ensure required database variables are set
          echo "" >> .env
          echo "# CI Test Overrides" >> .env
          echo "POSTGRES_DB=n8n_test" >> .env
          echo "POSTGRES_USER=n8n_test" >> .env
          echo "REDIS_DB=0" >> .env
          echo "N8N_LOG_LEVEL=debug" >> .env
          echo "N8N_DIAGNOSTICS_ENABLED=false" >> .env
          echo "N8N_VERSION_NOTIFICATIONS_ENABLED=false" >> .env
          echo "N8N_TEMPLATES_ENABLED=false" >> .env
          echo "N8N_ONBOARDING_FLOW_DISABLED=true" >> .env

      - name: Create external Docker network if not exists
        run: docker network create n8n-network || true

      - name: Build custom nodes for deployment tests
        run: |
          cd nodes
          npm ci
          npm run build

      - name: Test basic deployment
        if: matrix.deployment == 'basic'
        run: |
          echo "Starting basic deployment..."
          docker compose up -d

          # Wait for services to start
          echo "Waiting for services to start..."
          sleep 45

          # Check container status
          echo "Container status:"
          docker compose ps

          # Show logs for debugging
          echo "Service logs:"
          docker compose logs --tail=20

          # Test health endpoints with retry
          echo "Testing n8n health endpoint..."
          for i in {1..5}; do
            if curl -f http://localhost:5678/healthz; then
              echo "Health check passed!"
              break
            else
              echo "Health check attempt $i failed, retrying in 10s..."
              sleep 10
            fi
          done

          # Final health check
          curl -f http://localhost:5678/healthz || exit 1

          docker compose down -v
          # Cleanup test environment
          rm -f .env

      - name: Test Nginx deployment
        if: matrix.deployment == 'nginx'
        run: |
          echo "üöÄ Starting Nginx deployment test..."

          # Override N8N_HOST for nginx deployment (n8n should be accessible via nginx)
          sed -i 's/N8N_HOST=n8n.localhost/N8N_HOST=localhost/g' .env
          sed -i 's|WEBHOOK_URL=http://n8n.localhost/|WEBHOOK_URL=http://localhost/|g' .env

          echo "üìã Environment configuration for nginx:"
          grep -E "(N8N_HOST|WEBHOOK_URL|POSTGRES_)" .env

          # Ensure all critical environment variables are set
          echo "üìã Verifying all required environment variables:"
          echo "Complete .env file contents:"
          cat .env
          echo "---"

          # Check for empty or missing critical variables
          missing_vars=""
          for var in N8N_ENCRYPTION_KEY N8N_JWT_SECRET POSTGRES_USER POSTGRES_DB POSTGRES_PASSWORD REDIS_PASSWORD; do
            if ! grep -q "^${var}=" .env || grep -q "^${var}=$" .env; then
              missing_vars="$missing_vars $var"
            fi
          done

          if [ -n "$missing_vars" ]; then
            echo "‚ùå Missing or empty critical environment variables:$missing_vars"
            exit 1
          fi

          echo "‚úÖ All critical environment variables are set"

          # Ensure custom nodes are built and available
          echo "üìã Checking custom nodes build:"
          if [ -d "nodes/dist" ]; then
            ls -la nodes/dist/
            echo "Custom nodes content:"
            find nodes/dist -type f -name "*.js" | head -10
          else
            echo "‚ùå No custom nodes dist directory found - this might cause n8n startup issues"
            # Create empty directory to prevent mount issues
            mkdir -p nodes/dist
          fi

          # Create required data directories with proper permissions
          echo "üìã Setting up data directories:"
          mkdir -p data/n8n data/postgres data/redis
          chmod -R 755 data/

          # Verify Docker network exists
          echo "üìã Ensuring Docker network exists:"
          docker network create n8n-network || echo "Network already exists"
          docker network ls | grep n8n-network

          # Temporarily modify health check for more lenient CI testing
          echo "üìã Applying CI-specific health check configuration..."
          sed -i 's/start_period: 120s/start_period: 180s/' docker-compose.yml
          sed -i 's/retries: 5/retries: 8/' docker-compose.yml
          sed -i 's/interval: 30s/interval: 20s/' docker-compose.yml

          # Start services
          docker compose -f docker-compose.yml -f docker-compose.nginx.yml up -d

          # Wait for initial startup and monitor n8n startup
          echo "‚è≥ Waiting for services to start (monitoring n8n startup)..."
          sleep 30

          # Check n8n startup logs immediately
          echo "üìã N8N startup logs (first 30 seconds):"
          docker compose -f docker-compose.yml -f docker-compose.nginx.yml logs n8n --tail=50

          sleep 30

          # Check container status early
          echo "üìä Initial container status:"
          docker compose -f docker-compose.yml -f docker-compose.nginx.yml ps

          # Check if postgres is healthy first
          echo "üîç Checking PostgreSQL health..."
          for i in {1..10}; do
            if docker compose -f docker-compose.yml -f docker-compose.nginx.yml exec -T postgres pg_isready -U n8n_test -d n8n_test; then
              echo "‚úÖ PostgreSQL is ready!"
              
              # Test database connection with the exact credentials n8n will use
              echo "üîç Testing database connection with n8n credentials..."
              docker compose -f docker-compose.yml -f docker-compose.nginx.yml exec -T postgres psql -U n8n_test -d n8n_test -c "SELECT version();" || echo "‚ùå Database connection test failed"
              break
            else
              echo "‚è≥ PostgreSQL not ready yet (attempt $i/10), waiting 5s..."
              sleep 5
            fi
          done

          # Show early n8n logs to catch startup issues
          echo "üìã Early N8N container logs:"
          docker compose -f docker-compose.yml -f docker-compose.nginx.yml logs n8n --tail=30

          # Wait longer for n8n to be fully ready and check its health status
          echo "‚è≥ Waiting for n8n to be fully ready..."
          for i in {1..12}; do
            health_status=$(docker inspect n8n --format='{{.State.Health.Status}}' 2>/dev/null || echo "no-health")
            echo "N8N health status (attempt $i/12): $health_status"
            
            if [ "$health_status" = "healthy" ]; then
              echo "‚úÖ N8N is healthy!"
              break
            elif [ "$health_status" = "unhealthy" ]; then
              echo "‚ùå N8N is unhealthy, showing logs:"
              docker compose -f docker-compose.yml -f docker-compose.nginx.yml logs n8n --tail=20
            fi
            
            sleep 10
          done

          # Final container status check
          echo "üìä Final container status:"
          docker compose -f docker-compose.yml -f docker-compose.nginx.yml ps

          # Check n8n health directly (if possible)
          echo "üîç Checking n8n container health status..."
          health_status=$(docker inspect n8n --format='{{.State.Health.Status}}' 2>/dev/null || echo "no-health")
          echo "N8N health status: $health_status"

          # If unhealthy, check if n8n is actually listening on port 5678
          if [ "$health_status" = "unhealthy" ]; then
            echo "üîç Checking if n8n is listening on port 5678..."
            docker compose -f docker-compose.yml -f docker-compose.nginx.yml exec -T n8n netstat -tlnp | grep 5678 || echo "‚ùå N8N not listening on port 5678"
            
            echo "üîç Checking n8n process status..."
            docker compose -f docker-compose.yml -f docker-compose.nginx.yml exec -T n8n ps aux || echo "‚ùå Cannot check process status"
          fi

          # Show comprehensive logs before testing
          echo "üìã Complete N8N container logs:"
          docker compose -f docker-compose.yml -f docker-compose.nginx.yml logs n8n --tail=50

          echo "üìã PostgreSQL container logs:"
          docker compose -f docker-compose.yml -f docker-compose.nginx.yml logs postgres --tail=20

          echo "üìã Nginx container logs:"
          docker compose -f docker-compose.yml -f docker-compose.nginx.yml logs nginx --tail=20

          # Test Nginx health endpoint
          echo "üß™ Testing nginx health endpoint..."
          curl -f http://localhost/health || exit 1

          # Test that nginx can proxy to n8n
          echo "üß™ Testing nginx proxy to n8n healthz endpoint..."
          for i in {1..5}; do
            if curl -f http://localhost/healthz; then
              echo "‚úÖ N8N health check passed!"
              break
            else
              echo "‚ùå N8N health check attempt $i failed, retrying in 15s..."
              sleep 15
            fi
          done

          # Final attempt - if this fails, we'll see the error
          curl -f http://localhost/healthz || {
            echo "‚ùå Final n8n health check failed"
            echo "üìã Final N8N logs:"
            docker compose -f docker-compose.yml -f docker-compose.nginx.yml logs n8n --tail=100
            exit 1
          }

          echo "‚úÖ Nginx deployment test completed successfully"
          docker compose -f docker-compose.yml -f docker-compose.nginx.yml down -v
          # Cleanup test environment
          rm -f .env

      - name: Test Traefik deployment
        if: matrix.deployment == 'traefik'
        run: |
          docker compose -f docker-compose.yml -f docker-compose.traefik.yml up -d
          sleep 30
          docker compose ps
          # Test Traefik dashboard
          curl -f http://localhost:8080/ping || exit 1
          docker compose -f docker-compose.yml -f docker-compose.traefik.yml down -v

      - name: Test monitoring deployment
        if: matrix.deployment == 'monitoring'
        run: |
          # Setup monitoring directories with proper permissions (CI-friendly)
          mkdir -p monitoring/data/{prometheus,grafana,loki,alertmanager,uptime-kuma}
          chmod -R 777 monitoring/data/ || echo "Permission setup completed"

          echo "Starting monitoring stack..."
          docker compose -f docker-compose.monitoring.yml up -d

          # Wait longer for monitoring stack to be ready
          echo "Waiting for monitoring services to start..."
          sleep 90

          # Check container status
          echo "Container status:"
          docker compose -f docker-compose.monitoring.yml ps

          # Show logs for debugging
          echo "Service logs:"
          docker compose -f docker-compose.monitoring.yml logs --tail=10

          # Test monitoring endpoints with retries
          echo "Testing Prometheus..."
          curl -f http://localhost:9090/-/healthy || echo "Prometheus not ready"

          echo "Testing Grafana..."
          curl -f http://localhost:3000/api/health || echo "Grafana not ready"

          echo "Testing Loki..."
          curl -f http://localhost:3100/ready || echo "Loki not ready"

          # At least one service should be working
          curl -f http://localhost:9090/-/healthy || curl -f http://localhost:3100/ready || exit 1

          docker compose -f docker-compose.monitoring.yml down -v

  build-custom-nodes:
    name: Build Custom Nodes
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"

      - name: Cache npm dependencies
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('nodes/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install dependencies
        run: |
          echo "Current directory: $(pwd)"
          echo "Checking for package-lock.json in nodes directory:"
          ls -la nodes/package-lock.json
          cd nodes
          echo "Changed to directory: $(pwd)"
          npm ci

      - name: Build custom nodes
        run: |
          cd nodes
          npm run build

      - name: Test custom nodes
        run: |
          cd nodes
          npm test || echo "Tests completed with issues - continuing build"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        if: ${{ !env.ACT }}
        with:
          name: custom-nodes-dist
          path: nodes/dist/
          retention-days: 7

  performance-test:
    name: Performance Test
    runs-on: ubuntu-latest
    needs: [test-deployment]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up environment
        run: |
          cp .env.example .env
          sed -i 's/changeme123!/test_password_123!/g' .env
          sed -i 's/change-this-secure-password/test_secure_password!/g' .env
          sed -i 's/generate-32-character-key-here/test-encryption-key-32-characters/g' .env
          sed -i 's/generate-jwt-secret-here/test-jwt-secret-key/g' .env

          echo "" >> .env
          echo "# Performance Test Overrides" >> .env
          echo "POSTGRES_DB=n8n_test" >> .env
          echo "POSTGRES_USER=n8n_test" >> .env

      - name: Start N8N
        run: |
          docker compose up -d
          sleep 30

      - name: Install k6
        run: |
          sudo gpg -k
          sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
          echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install k6

      - name: Run performance tests
        run: |
          # Create basic performance test
          cat > perf-test.js << 'EOF'
          import http from 'k6/http';
          import { check } from 'k6';

          export let options = {
            stages: [
              { duration: '30s', target: 10 },
              { duration: '1m', target: 10 },
              { duration: '30s', target: 0 },
            ],
          };

          export default function() {
            let response = http.get('http://localhost:5678/healthz');
            check(response, {
              'status is 200': (r) => r.status === 200,
              'response time < 500ms': (r) => r.timings.duration < 500,
            });
          }
          EOF

          k6 run perf-test.js

      - name: Cleanup
        if: always()
        run: |
          docker compose down -v
          rm -f .env

  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs:
      [lint-and-validate, security-scan, test-deployment, build-custom-nodes]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate version
        id: version
        run: |
          # Get the latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $LATEST_TAG"

          # Generate new version (simple increment for now)
          if [[ $LATEST_TAG =~ v([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
            MAJOR=${BASH_REMATCH[1]}
            MINOR=${BASH_REMATCH[2]}
            PATCH=${BASH_REMATCH[3]}
            NEW_PATCH=$((PATCH + 1))
            NEW_VERSION="v${MAJOR}.${MINOR}.${NEW_PATCH}"
          else
            NEW_VERSION="v1.0.0"
          fi

          echo "New version: $NEW_VERSION"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Create Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.version.outputs.version }}
          release_name: Release ${{ steps.version.outputs.version }}
          body: |
            ## Changes in ${{ steps.version.outputs.version }}

            ### Added
            - Automated release from CI/CD pipeline

            ### Security
            - All security scans passed
            - Docker images scanned for vulnerabilities

            ### Testing
            - All deployment configurations tested
            - Performance tests completed

            See [CHANGELOG.md](CHANGELOG.md) for detailed changes.
          draft: false
          prerelease: false

  notify:
    name: Notify
    runs-on: ubuntu-latest
    needs:
      [lint-and-validate, security-scan, test-deployment, build-custom-nodes]
    if: always()
    steps:
      - name: Notify on success
        if: needs.lint-and-validate.result == 'success' && needs.security-scan.result == 'success' && needs.test-deployment.result == 'success' && needs.build-custom-nodes.result == 'success'
        run: |
          echo "‚úÖ All CI/CD checks passed successfully!"

      - name: Notify on failure
        if: needs.lint-and-validate.result == 'failure' || needs.security-scan.result == 'failure' || needs.test-deployment.result == 'failure' || needs.build-custom-nodes.result == 'failure'
        run: |
          echo "‚ùå CI/CD pipeline failed. Check the logs for details."
          echo "Job results:"
          echo "  - lint-and-validate: ${{ needs.lint-and-validate.result }}"
          echo "  - security-scan: ${{ needs.security-scan.result }}"
          echo "  - test-deployment: ${{ needs.test-deployment.result }}"
          echo "  - build-custom-nodes: ${{ needs.build-custom-nodes.result }}"
          exit 1

      - name: Notify on partial completion
        if: |
          (needs.lint-and-validate.result == 'success' || needs.lint-and-validate.result == 'skipped') &&
          (needs.security-scan.result == 'success' || needs.security-scan.result == 'skipped') &&
          (needs.test-deployment.result == 'success' || needs.test-deployment.result == 'skipped') &&
          (needs.build-custom-nodes.result == 'success' || needs.build-custom-nodes.result == 'skipped') &&
          !(needs.lint-and-validate.result == 'success' && needs.security-scan.result == 'success' && needs.test-deployment.result == 'success' && needs.build-custom-nodes.result == 'success')
        run: |
          echo "‚ö†Ô∏è  CI/CD pipeline completed with some jobs skipped."
          echo "Job results:"
          echo "  - lint-and-validate: ${{ needs.lint-and-validate.result }}"
          echo "  - security-scan: ${{ needs.security-scan.result }}"
          echo "  - test-deployment: ${{ needs.test-deployment.result }}"
          echo "  - build-custom-nodes: ${{ needs.build-custom-nodes.result }}"
